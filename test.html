<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>test</title>
    <style>
      .rhomboid {
        width: 300px;
        height: 200px;
        background: #f00;
        transform: skew(-30deg);
      }
    </style>
  </head>
  <body>
    <div class="rhomboid"></div>

    <script>
      // 如何实现提案中的flat函数（参数为几就拆解几层数组）
      Array.prototype._flat = function (level) {
        function helper (array, level) {
          const res = [];
          array.forEach((item) => {
            if (level > 0 && Array.isArray(item)) {
              res.push(...helper(item, level - 1));
            }
            else {
              res.push(item);
            }
          });
          return res;
        }

        return helper(this, level);
      };

      // 2x1的地砖铺 nx2的地板



      function selectSort (nums) {
        for (let i = 0; i < nums.length - 1; i++) {
          for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] > nums[j]) {
              [nums[i], nums[j]] = [nums[j], nums[i]];
            }
          }
        }
      }

      function mergeSort (nums) {
        if (nums.length <= 1) {
          return nums;
        }

        let mid = ~~(nums.length / 2);

        return mergeSortHelper(mergeSort(nums.slice(0, mid)), mergeSort(nums.slice(mid)));
      }

      function mergeSortHelper (left, right) {
        const res = [];
        while (left.length && right.length) {
          // 不断比较left,right第一项, 取出较小的
          left[0] < right[0] ? res.push(left.shift()) : res.push(right.shift());
        }
        return res.concat(left, right);
      }

      // 防抖: 多次调用, 运行1次
      function debounce (fn, timeout = 300) {
        return function (...args) {
          clearTimeout(fn._tid);
          fn._tid = setTimeout(() => {
            fn.call(this, ...args);
          }, timeout);
        };
      }

      // 节流: 多次调用, 每个时间间隔运行1次
      function throttle (fn, timeout = 300) {
        let start = Date.now();
        return function (...args) {
          const now = Date.now();
          if (now - start >= timeout) {
            fn.call(this, ...args);
            start = now;
          }
        };
      }

      // 柯里化
      function curry (fn, ...prevArgs) {
        return function (...args) {
          const newArgs = [...prevArgs, ...args];
          // 参数数量不足
          if (newArgs.length < fn.length) {
            return curry(fn, ...newArgs);
          }
          else {
            return fn(...newArgs);
          }
        };
      }

      function toCurryLog (a, b, c) {
        console.log(`${a},${b},${c}`);
      }

      const curryLog = curry(toCurryLog);
      curryLog(1)(2, 3);

      class EventEmitter {
        constructor () {
          this.events = {};
        }

        on (type, fn) {
          const typeFns = this.events[type] || (this.events[type] = []);
          typeFns.push(fn);
          return this;
        }

        once (type, fn) {
          const tmpFn = (...args) => {
            fn.call(this, ...args);
            this.off(type, tmpFn);
          };
          this.on(type, tmpFn);
          return this;
        }

        emit (type, ...args) {
          const typeFns = this.events[type] || [];
          typeFns.forEach((fn) => fn.call(this, ...args));
          return this;
        }

        off (type, fn) {
          if (fn === undefined) {
            this.events[type] = null;
          }
          else {
            const typeFns = this.events[type] || [];
            typeFns.splice(typeFns.indexOf(fn), 1);
          }
          return this;
        }
      }
    </script>
  </body>
</html>
